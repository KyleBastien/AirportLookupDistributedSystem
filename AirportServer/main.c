/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   main.c
 * Author: cc
 *
 * Created on February 8, 2016, 9:32 AM
 */

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

//#include "../airports.h"
#include "kdtree.h"
#include <stdio.h>
#include <stdlib.h>
//#include <../rpc/map_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <ctype.h>
#include <unistd.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif



//===========================ADDED CODE=============================
//__NetBeans somehow does not recognize MAXLEN...cc
#define MAXLEN 200
static const char filename[] = "airport-locations.txt";
static struct kdtree *kd;

#include <math.h>
#define pi 3.14159265358979323846
/*
double distance(double lat1, double lon1, double lat2, double lon2, char unit) {
    double theta, dist;
    theta = lon1 - lon2;
    dist = sin(deg2rad(lat1)) * sin(deg2rad(lat2)) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * cos(deg2rad(theta));
    dist = acos(dist);
    dist = rad2deg(dist);
    dist = dist * 60 * 1.1515;
    switch (unit) {
            case 'M': break;
        case 'K':
            dist = dist * 1.609344;
            break;
        case 'N':
            dist = dist * 0.8684;
            break;
    }
    return (dist);
}
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//:: This function converts decimal degrees to radians:
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
double deg2rad(double deg) {
    return (deg * pi / 180);
}
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//:: This function converts radians to decimal degrees: 
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
double rad2deg(double rad) {
    return (rad * 180 / pi);
}
*/

// struct to store place (line in text file)

struct airport {
    char code[3];
    char name[MAXLEN];
    char state[2];
    float latitude;
    float longitude;
};

typedef struct airport Airport;

char *trim(char *s) {
    while (isspace(*s)) s++;
    s[strlen(s) - 1] = '\0';
    return s;
}


// This function parses the line that is read and stores data in the "place" struct

Airport * parseLine(char * line) {

    Airport *a = malloc(sizeof *a);
    int length = strlen(line);
    char temp[MAXLEN];

    //code
    strncpy(a->code, line + 1, 3); // code

    //state
    strncpy(a->name, line + 19, length - 19 + 3);
    strncpy(a->name, trim(a->name), strlen(a->name)); // trimming spaces

    //latitiude
    strncpy(temp, line + 6, 5);
    a->latitude = atof(temp);

    //longitude
    strncpy(temp, line + 12, 7);
    a->longitude = atof(temp);


    // Uncomment code below if you want to see the data being printed out

    /*
    printf(a->code);
    printf(a->name);
    printf("%.6f",a->latitude);
    printf("%.6f\n",a->longitude);
     */
    return a;

};

// Function to read file airport-locations.txt

void readFile() {
    FILE *file = fopen(filename, "r");
    char line[MAXLEN]; //temp storage for line
    //int count = 0;
    if (file != NULL) {
        fgets(line, sizeof line, file); // disregard first line
        while (fgets(line, sizeof line, file) != NULL) { //read line
            //printf("working on line # %i\n",count++);
            // parse line and get data in struct
            if (strchr(line, ',')) {
                Airport *a = parseLine(line);
                float coords[] = {a->latitude, a->longitude};
                
                kd_insertf(kd, coords, a);               
            }
            // TODO: Use Airport struct store in datastructure

        }
        fclose(file);
    }
}


int
main(int argc, char **argv) {
    /*
        register SVCXPRT *transp;

        pmap_unset (AIRPORTSPROG, AIRPORTS_VERS);

        transp = svcudp_create(RPC_ANYSOCK);
        if (transp == NULL) {
                fprintf (stderr, "%s", "cannot create udp service.");
                exit(1);
        }
        if (!svc_register(transp, AIRPORTSPROG, AIRPORTS_VERS, airportsprog_1, IPPROTO_UDP)) {
                fprintf (stderr, "%s", "unable to register (AIRPORTSPROG, AIRPORTS_VERS, udp).");
                exit(1);
        }

        transp = svctcp_create(RPC_ANYSOCK, 0, 0);
        if (transp == NULL) {
                fprintf (stderr, "%s", "cannot create tcp service.");
                exit(1);
        }
        if (!svc_register(transp, AIRPORTSPROG, AIRPORTS_VERS, airportsprog_1, IPPROTO_TCP)) {
                fprintf (stderr, "%s", "unable to register (AIRPORTSPROG, AIRPORTS_VERS, tcp).");
                exit(1);
        }
     */

    kd = kd_create(2);
    readFile(); //kd);
    //svc_run ();
    float coords[2] = { 40.0f, -80.0f};

    struct kdres *searchResults = kd_nearest_rangef(kd, coords, 2.0f);
    printf("found %d results:\n", kd_res_size(searchResults));

    


    fprintf(stderr, "%s", "svc_run returned");
    exit(1);
    /* NOTREACHED */
}


